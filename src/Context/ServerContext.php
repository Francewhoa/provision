<?php

namespace Aegir\Provision\Context;

use Aegir\Provision\Console\Config;
use Aegir\Provision\ContextProvider;
use Aegir\Provision\Property;
use Aegir\Provision\Provision;
use Aegir\Provision\Service\DockerServiceInterface;
use Psr\Log\LogLevel;
use Symfony\Component\Config\Definition\ConfigurationInterface;
use Symfony\Component\Filesystem\Filesystem;
use Symfony\Component\Yaml\Yaml;

/**
 * Class ServerContext
 *
 * @package Aegir\Provision\Context
 *
 * @see \Provision_Context_server
 */
class ServerContext extends ContextProvider implements ConfigurationInterface
{
    /**
     * @var string
     * 'server', 'platform', or 'site'.
     */
    public $type = 'server';
    const TYPE = 'server';

    public $server_config_path;

    /**
     * ServerContext constructor.
     *
     * Prepares "server_config_path" as the place to store this server's service
     * configuration files (apache configs, etc.).
     *
     * @param $name
     * @param Provision $provision
     * @param array $options
     */
    function __construct($name, Provision $provision, array $options = [])
    {
        // @TODO: Create a 'servers_path' to keep things nice and clean.
        parent::__construct($name, $provision, $options);
        $this->server_config_path = $this->getProvision()->getConfig()->get('config_path') . DIRECTORY_SEPARATOR . $name;
        $this->properties['server_config_path'] = $this->server_config_path;

        $this->fs = new Filesystem();
    }

    /**
     * @return string|Property[]
     */
    static function option_documentation()
    {
        return [
            'remote_host' =>
                Provision::newProperty()
                    ->description('server: host name')
                    ->required(TRUE)
                    ->defaultValue('localhost')
                    ->validate(function($remote_host) {
                        // If remote_host doesn't resolve to anything, warn the user.
                        $ip = gethostbynamel($remote_host);
                        if (empty($ip)) {
                            throw new \RuntimeException("Hostname $remote_host does not resolve to an IP address. Please try again.");
                        }
                        return $remote_host;
                  }),
            'script_user' =>
                Provision::newProperty()
                    ->description('server: OS user name')
                    ->required(TRUE)
                    ->defaultValue(Config::getScriptUser()),
            'aegir_root' =>
                Provision::newProperty()
                    ->description('server: aegir user home directory')
                    ->required(TRUE)
                    ->defaultValue(Config::getHomeDir()),
            // @TODO: Why do server contexts need a master_url?
            'master_url' =>
                Provision::newProperty()
                    ->description('server: Hostmaster URL')
                    ->required(FALSE)
        ];
    }

    /**
     * @return array
     */
    public function verify()
    {
        $tasks = [];

        // @TODO: Figure out how to put this in it's own class or something... How can we avoid hard coding docker-compose in here?
        $is_docker_server = FALSE;
        $compose_services = [];
        $filename = $this->getProperty('server_config_path') . DIRECTORY_SEPARATOR . 'docker-compose.yml';

        // Load docker compose data from each docker service.
        $this->getServices();
        foreach ($this->getServices() as $type => $service) {
            if ($service instanceof DockerServiceInterface) {
                $compose_services[$type] = $service->dockerComposeService();
                $compose_services[$type]['hostname'] = $this->name . '.' . $type;

                $is_docker_server = TRUE;
            }
        }

        // If there are any docker services in this server create a
        // docker-compose file.
        if ($is_docker_server) {
            $compose = array(
                'version' => '2',
                'services' => $compose_services,
            );

            $tasks['docker.compose.write'] = Provision::newTask()
                ->start('Generating docker-compose.yml file...')
                ->success('Generating docker-compose.yml file... Saved to ' . $filename)
                ->failure('Generating docker-compose.yml file... Saved to ' . $filename)
                ->execute(function () use ($compose, $filename) {

                    $filename = $this->getProperty('server_config_path') . DIRECTORY_SEPARATOR . 'docker-compose.yml';
                    $server_name = $this->name;
                    $yml_prefix = <<<YML
# Provision Docker Compose File
# =============================
# Server: $server_name
#
# $filename
# 
# DO NOT EDIT THIS FILE.
# This file was automatically generated by Provision CLI.
#
# To re-generate this file, run the command:
#
#    provision verify $server_name
#
# Soon there will be an easy way for you to modify this file automatically.
# THANKS!

YML;
                    $yml_dump = $yml_prefix . Yaml::dump($compose, 5, 2);
                    $debug_message = 'Generated Docker Compose file: ' . PHP_EOL . $yml_dump;
                    $this->getProvision()->getTasks()->taskLog($debug_message, LogLevel::INFO)->run()->getExitCode();

                    $this->fs->dumpFile($filename, $yml_dump);

                    // @TODO: Right now the aegir/web container is looking for docker.conf so let's give them that.
                    $source = $this->server_config_path . DIRECTORY_SEPARATOR . 'apacheDocker.conf';
                    $destination = $this->server_config_path . DIRECTORY_SEPARATOR . 'docker.conf';
                    $this->fs->copy($source, $destination);
                });

            $tasks['docker.compose.up'] = Provision::newTask()
                ->start("Running <info>docker-compose up -d</info> in <info>{$this->server_config_path}</info> ...")
                ->execute(function() {

                    return Provision::getProvision()->getTasks()->taskExec('docker-compose')
                        ->dir($this->server_config_path)
                        ->arg('up')
                        ->arg('-d')
                        ->silent(!$this->getProvision()->getOutput()->isVerbose())
                        ->run()
                        ->getExitCode()
                    ;
                });

        }
        return $tasks;
    }

    /**
     * Run a shell command on this server.
     *
     * @TODO: Run remote commands correctly.
     *
     * @param $cmd
     * @return string
     * @throws \Exception
     */
    public function shell_exec($cmd) {
        $output = '';
        $exit = 0;
        exec($cmd, $output, $exit);

        if ($exit != 0) {
            throw new \Exception("Command failed: $cmd");
        }

        return implode("\n", $output);
    }
}
